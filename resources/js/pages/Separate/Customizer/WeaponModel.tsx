/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Author: MCTav1sh (https://sketchfab.com/MCTav1sh)
License: CC-BY-4.0 (http://creativecommons.org/licenses/by/4.0/)
Source: https://sketchfab.com/3d-models/ppsh-41-tactical-d7d785b781a94df5b9a4956f64bc3e93
Title: PPSH-41 TACTICAL
*/

import { state } from '@/stores/customizerProxy';
import { Weapon } from '@/types/types';
import { CameraControls, Stage, TransformControls, useGLTF } from '@react-three/drei';
import { JSX, RefObject, useEffect, useMemo, useRef } from 'react';
import * as THREE from 'three';
import { GLTF } from 'three-stdlib';
import { useSnapshot } from 'valtio';

type GLTFResult = GLTF & {
    nodes: Record<string, THREE.Mesh>;
    materials: {
        perst: THREE.MeshStandardMaterial;
        material_12: THREE.MeshStandardMaterial;
        ammo: THREE.MeshStandardMaterial;
        mag_35: THREE.MeshPhysicalMaterial;
        scope: THREE.MeshStandardMaterial;
        linza: THREE.MeshPhysicalMaterial;
        material: THREE.MeshStandardMaterial;
        text_set: THREE.MeshPhysicalMaterial;
        text_set3: THREE.MeshStandardMaterial;
        text_set2: THREE.MeshPhysicalMaterial;
        text_set1: THREE.MeshPhysicalMaterial;
        texture_set2: THREE.MeshPhysicalMaterial;
        texture_set1: THREE.MeshPhysicalMaterial;
    };
};

type ModelProps = JSX.IntrinsicElements['group'] & {
    weapon: Weapon;
    cameraControlsRef: RefObject<CameraControls>;
};

type WorldNode = {
    uuid: string;
    geometry: THREE.BufferGeometry;
    material: THREE.Material | THREE.Material[];
    position: [number, number, number];
    rotation: [number, number, number];
    scale: [number, number, number];
    visible: boolean;
};

export default function Model({ cameraControlsRef, weapon, ...props }: ModelProps) {
    const { nodes, materials, scene } = useGLTF(`/3DModels/${weapon.name}/scene.glb`) as unknown as GLTFResult;

    const meshRefs = useRef<Record<string, THREE.Mesh | null>>({});
    const sceneGroupRef = useRef<THREE.Group>(null);
    const selectionGroupRef = useRef<THREE.Group>(null);

    const worldNodes = useMemo(() => {
        scene.updateMatrixWorld(true);
        return Object.entries(nodes).reduce(
            (acc, [nodeName, n]) => {
                const pos = new THREE.Vector3();
                const scale = new THREE.Vector3();
                const quat = new THREE.Quaternion();
                const euler = new THREE.Euler();
                n.getWorldPosition(pos);
                n.getWorldScale(scale);
                n.getWorldQuaternion(quat);
                euler.setFromQuaternion(quat, 'XYZ');
                acc[nodeName] = {
                    uuid: n.uuid,
                    geometry: n.geometry,
                    material: n.material,
                    position: [pos.x, pos.y, pos.z] as [number, number, number],
                    rotation: [euler.x, euler.y, euler.z] as [number, number, number],
                    scale: [scale.x, scale.y, scale.z] as [number, number, number],
                    visible: 'visible' in n ? n.visible : true,
                };
                return acc;
            },
            {} as Record<string, WorldNode>,
        );
    }, [scene, nodes]);

    useMemo(() => {
        if (materials.material) {
            if (materials.material.normalMap) {
                materials.material.normalScale.set(0.5, 0.5);
            }
            materials.material.roughness = 0.5;
            materials.material.metalness = 0.8;
        }
    }, [materials]);

    state.dbAttachmentsToMaterialsObject = useMemo(() => {
        const map: Record<string, string[]> = {};
        map['Foregrip'] = ['defaultMaterial_19'];
        map['Red Dot Sight'] = ['defaultMaterial_13', 'defaultMaterial_14', 'defaultMaterial_15'];
        map['Laser Sight'] = Array.from({ length: 10 }, (_, i) => `defaultMaterial_${i + 1}`);
        map['Laser Sight'].push('defaultMaterial');

        return map;
    }, []);

    useEffect(() => {
        state.nodeNames = Object.keys(worldNodes);
    }, [worldNodes]);

    const snap = useSnapshot(state);
    const initAppliedRef = useRef(false);

    useEffect(() => {
        if (!snap.grouped || initAppliedRef.current || !meshRefs.current) return;

        Object.values(state.dbAttachmentsToMaterialsObject).forEach((nodeNames) => {
            nodeNames.forEach((nodeName) => {
                const n = meshRefs.current[nodeName];
                if (n && 'visible' in n) n.visible = false;
            });
        });

        Object.values(snap.selected).forEach((selAtt) => {
            (state.dbAttachmentsToMaterialsObject[selAtt.name] ?? []).forEach((nodeName) => {
                const n = meshRefs.current[nodeName];
                if (n && 'visible' in n) n.visible = true;
            });
        });

        initAppliedRef.current = true;
    }, [snap.grouped, snap.selected]);

    useEffect(() => {
        if (!snap.grouped || !meshRefs.current) return;

        (snap.grouped[state.currentAreaSelection] ?? []).forEach((att) => {
            (state.dbAttachmentsToMaterialsObject[att.name] ?? []).forEach((nodeName) => {
                const n = meshRefs.current[nodeName];
                if (n && 'visible' in n) n.visible = false;
            });
        });

        const currentSelectedMaterialNames = state.dbAttachmentsToMaterialsObject[snap.selected[state.currentAreaSelection]?.name];
        if (!currentSelectedMaterialNames) return;
        currentSelectedMaterialNames.forEach((nodeName) => {
            const n = meshRefs.current[nodeName];
            if (n) n.visible = true;
        });
    }, [nodes, snap.grouped, snap.selected]);

    const HOVER_COLOR = '#ff0000'; // Red for hover
    const SELECTED_COLOR = '#0000ff'; // Blue for selected

    function ensureUniqueMaterial(mesh: THREE.Mesh | undefined) {
        if (!mesh) return;
        if (Array.isArray(mesh.material)) {
            mesh.material = mesh.material.map((m: any) => m.clone());
        } else {
            mesh.material = (mesh.material as any).clone();
        }
    }

    function addToSelection() {
        if (!meshRefs.current || !sceneGroupRef.current || !selectionGroupRef.current) return;

        const nodeName = snap.currentMesh[1] as (typeof state.currentMesh)[1];
        if (!nodeName) return;
        const newMat = Array.isArray(meshRefs.current[nodeName]?.material)
            ? meshRefs.current[nodeName].material[0]
            : meshRefs.current[nodeName]?.material;

        if ((newMat as any)?.color?.isColor && meshRefs.current[nodeName]) {
            if (!meshRefs.current[nodeName].userData.__originalColor) {
                meshRefs.current[nodeName].userData.__originalColor = (newMat as any).color.clone();
            }
            (newMat as any).color.set(SELECTED_COLOR);
        }

        if (meshRefs.current[nodeName]) {
            selectionGroupRef.current.attach(meshRefs.current[nodeName]);
        }

        console.log('SHIFT CLICKED!!!');
    }

    function changeSelection() {
        if (!meshRefs.current || !sceneGroupRef.current || !selectionGroupRef.current) return;

        const previousSelection = snap.currentMesh[0];
        previousSelection.map((nodeName) => {
            const previousMeshRef = meshRefs.current[nodeName];
            if (previousMeshRef) {
                const prevMat = Array.isArray(previousMeshRef.material) ? previousMeshRef.material[0] : previousMeshRef.material;
                if ((prevMat as any)?.color?.isColor && previousMeshRef.userData.__originalColor) {
                    (prevMat as any).color.set(previousMeshRef.userData.__originalColor);
                }
                sceneGroupRef.current!.attach(previousMeshRef);
            }
        });

        state.currentMesh[0] = state.currentMesh[2];
        const nodeName = snap.currentMesh[1] as (typeof state.currentMesh)[1];
        if (!nodeName) return;
        const newMat = Array.isArray(meshRefs.current[nodeName]?.material)
            ? meshRefs.current[nodeName].material[0]
            : meshRefs.current[nodeName]?.material;

        if ((newMat as any)?.color?.isColor && meshRefs.current[nodeName]) {
            if (!meshRefs.current[nodeName].userData.__originalColor) {
                meshRefs.current[nodeName].userData.__originalColor = (newMat as any).color.clone();
            }
            (newMat as any).color.set(SELECTED_COLOR);
        }

        if (meshRefs.current[nodeName]) {
            selectionGroupRef.current.attach(meshRefs.current[nodeName]);
        }
    }

    useEffect(() => {
        if (snap.action) {
            if (snap.action === 'CHANGESELECTION') changeSelection();
            if (snap.action === 'ADDTOSELECTION') addToSelection();
        }
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [snap.lastUpdateId]);

    return (
        <>
            <Stage environment="studio" intensity={0.2} castShadow={true} shadows preset="upfront">
                <group>
                    <CameraControls
                        enabled={snap.cameraControlsEnabled}
                        ref={cameraControlsRef}
                        minDistance={2}
                        maxDistance={7}
                        minPolarAngle={Math.PI / 6}
                        maxPolarAngle={Math.PI / 1.8}
                        onControlEnd={() => handleControlEnd()}
                    />
                    <group {...props} dispose={null} rotation={[0, Math.PI / 2, 0]} scale={0.115} position={[0.75, 0.25, 0]}>
                        <group rotation={[0, 0, 0]} ref={sceneGroupRef}>
                            {Object.entries(worldNodes).map(([nodeName, n]) => (
                                <mesh
                                    name={nodeName}
                                    ref={(el) => (meshRefs.current[nodeName] = el)}
                                    key={n.uuid}
                                    castShadow
                                    receiveShadow
                                    position={n.position}
                                    rotation={n.rotation}
                                    geometry={n.geometry}
                                    material={n.material}
                                    visible={meshRefs.current[nodeName]?.visible ?? true}
                                    scale={n.scale}
                                    onDoubleClick={(e) => {
                                        e.stopPropagation();
                                        if (e.shiftKey) {
                                            state.currentMesh[0] = [...state.currentMesh[2]];
                                            state.currentMesh[1] = e.object.name;
                                            state.currentMesh[2].push(e.object.name);
                                            state.action = 'ADDTOSELECTION';
                                        } else {
                                            state.currentMesh[0] = [...state.currentMesh[2]];
                                            state.currentMesh[1] = e.object.name;
                                            state.currentMesh[2] = [e.object.name];
                                            state.action = 'CHANGESELECTION';
                                        }
                                        state.lastUpdateId++;
                                    }}
                                    onPointerEnter={(e) => {
                                        e.stopPropagation();
                                        const mesh = e.object as THREE.Mesh;
                                        ensureUniqueMaterial(mesh);
                                        const mat = Array.isArray(mesh.material) ? mesh.material[0] : mesh.material;
                                        if (!mesh.userData.__originalColor) {
                                            mesh.userData.__originalColor = (mat as any).color.clone();
                                        }
                                        (mat as any).color.set(HOVER_COLOR);
                                        if (typeof document !== 'undefined') document.body.style.cursor = 'pointer';
                                    }}
                                    onPointerLeave={(e) => {
                                        const mesh = e.object as THREE.Mesh;
                                        const mat = Array.isArray(mesh.material) ? mesh.material[0] : mesh.material;
                                        const original: THREE.Color | undefined = mesh.userData.__originalColor;

                                        if (mesh.name === snap.currentMesh[1]) {
                                            (mat as any).color.set(SELECTED_COLOR);
                                        } else if (original) {
                                            (mat as any).color.copy(original);
                                        }

                                        if (typeof document !== 'undefined') document.body.style.cursor = 'auto';
                                    }}
                                />
                            ))}
                            <group ref={selectionGroupRef}></group>
                        </group>
                    </group>
                </group>
            </Stage>
            {snap.mode && (
                <TransformControls
                    object={selectionGroupRef.current ?? undefined}
                    mode={snap.mode}
                    onMouseDown={() => (state.cameraControlsEnabled = false)}
                    onMouseUp={() => (state.cameraControlsEnabled = true)}
                />
            )}
        </>
    );
}

function handleControlEnd(): void {
    state.currentAreaSelection = 'other';
}

useGLTF.preload('/3DModels/PPSH41/scene.gltf');
